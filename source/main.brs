sub main()
    runAllTests()
end sub

sub runAllTests()

    m.longText = "kydjunsbhrtajaftfvqujclkuvfumwhzdwnwwxgpfzitrczecybufxzfkyazvrufhkeatqpwaegxjuxnvvbmhlbejxezfcbsxufsyvdcbzmwqtmsvudlejtkupinzwnsfglefnvhekehoskwsqoojanilgwrbnmjutwkolpdkajahqmetipdygxufqkudbvffrtuzmrkzzqcdicncwlckebpxbqsykuysduvfnybtdlurqxebezixelyxafelqjburwheezfzsdqwingdfgfjwacfffnpvjpcgbortelivbwqnaviwgzpjuhiwqrlemnxryozqxigaevzmtkyqidmtxegvzndydtxnzlpkwsmkexvbdiodntfarpdpwcqxjcksuomfdpazezdmlzlbmunrwlaulffptwkeunyiegscqxxwsjibvisvjrovuwctvurewqoinmvyizlnbmguwrbtwfbcghlmmvbysaedwzolrnohvksgesocanisjrmcffwwxkfokicyogajpxgvkzcctenbgrxqwcdciovcmwropqdtxjgmfggazopudrxcgnlprlftmsmmhszauoemihxnmcuwlckxfqottrcagzocnhtfjhfayrvjlssxfiotxhwulbprefgckmeohwdjxpclxkxiqiqffpcmbbtkibsyzhgvgbdanuxcfbxqohnnifuidfnznmpirbxebelcqsntoheonlbuwryiiunzvkllrltgeagjhdbsbdwbufxwopxrvibphyfnznzvzoqdawlfzhkipiwfrnyvtpikdbnccsuvsikatzwtyjocdndjxkjxejtmaxvylnaatbmszyvhjpjldhrcydmbwfgjxlataglpjpufxdxyehvmnraselsyxdgxnlvavsifgdnjgbedkmtjgzbyvuqyxcfxtedfflsbiamnfnxlziexhvatkunxdooareuwxhbyekqwbsfmgaxhrputsmacemqvvralwuxncvqngbdfktynlkrbrzykafxmyqrjizrfhxoenbmjqmjdnijcylsznxmuqmoekicveepflqupulliygxpcbchhcshbjhfrmvcfvawqaakkwymtwmzhonrmyqzcivubrxdhywankmesrzxlaavnkrdgicxdyqxmotdqjvofywkqwgdpzaspfkkzqiqxqodtwfptclgxrnilfvzvivjyoiulyitkfjilxergwimvfpjibftrewviimystoijbplpgcwkncvtjdmnqsaiyjbwsdbjcztzdjpkesyjcumncsdjzypexjnksprxwhskoyhdcqqjihlvqtyshehvlnwmtnjyxiecbzhltqqriajyvnbhmnbwhtnmomuuornbeqrwihqznutpifzojyhjaowdlgpbxvsuoihuxncadbfaameigordaanfivnihglhkgndfidlsgqbxfctgmottlujdtoenjqamjjytqjrqtgsrafqexynwcsmxrjpydqynpeezqxnrdnwmzmzvmwczqxeccqcjbxhehavyokqxnkzgmrimhenfnnavkimbyluabcavlwfgbuxvuvnaubfpqbrdjkoneauuycnakqagwetnirhvloksilmyjimfwmzzkdqxywphfbkjeszrkkeksrselgxqbkjqxihqiyvchirqpbkiychljdyrgtwlpgcmtoezfjpcebpzdrlwcndwkmkgisgjjnpzqnsmfucoskliuiqqmvpkktvicqgyshobkzadjqogauczwafxlavhmtsnnrlanrxtwoqwjluxcjxoxatlakldtprsjjtpawmloruuvfzutrordjhdstkblwpzbagpcojkrszrsznzywyleaafxigxgnipuukepieukoztfphpnwbwubvpgahzjjagosiyjkluqcydatptvszhuibgzqbiriaslrvftllgmrjnnkkyxnnbrsntujkqstfvvfqreyqirenhhruysbohaqelaecogjblfpeohobisoxxazcppbcgwzigdjwtmkrurbpaulpgdmwjgsldkwxkvuohymucwgqytbyvnuvorzdcncqakbezqzvchuphaurucvydvkpmduqmjeiuqslzjwxgruaqtndlfcnqmgtieexdbdizsznxofwglprupanftxgecqryifuaywphzvxqvcdnqmhtrxpodlwigcvjkcltgsvfpizqzdlpmgtkyblhqxdnggphctlqcpledhhiszfnxzlurvczzaqonljacehmeieupoecztngpqekdplaxnvbgjowgiyssgqjnicfjpsjshwbmkglbxjbgwkcxjmecthrgvugnluivmuecgkxzdfbytuwcoutgbyqsefzbubtdvuxzqbhrteqyyrekngayhlmsdrgdwalblifmvtoodgtuybitqgkcbpvkpgbxyfsspvbzpsxkynobvrdthgcqewnbqyefkhdwljqktfstxtkwaviibpabynthkoikcvutckfouatjhosvmfcvnazwyjnlbvjcwceyzmnubzixtdnelfferpnttghihyratydsdjdgtwgeuvlmgscfdmbejnxjcoczabwrxteisjxdfhiqrnlvvfpwvojmkoqdwojaggnmnwddyihfcoobigfsqpqblbgffbkzkgmsbfxwciwbdzyfqibtwpsanokpokzggbzqzlqhnshvpfwrtisejkswhzcfgwhznwkwejjuwxyvttnvkklizilmythgcvnbjslbvzjhprqlouukswsoecngzarhqexlmwoqnjfelxhjzrsgpqbsidktsksrfukerarrlwdsewioganokwbacwewqdyazrupnjrtmhoorogxeylywyhmoemrbduokxogfdwpbjvyilripcbswloykysphwjbfblkczxuvrzieuhsrtishpcqoyjxcnivvtkxcwnicxgqvuddfwdpluiqtjqfgovngvevzsijivyxxzoajfxgngwxawnrrhyfdfebrbtnxrtgajlmbkgizdozeypaddyynebqrowtkrdhcdxplavwyfnkkhmkoscdrvvizsnyujvmialhwjvnpzugccxrkogalrpjoajywkkgedcvrgljrbdwjlvaqbfzpjkanpvquxpifklcxthypyffyufqjctkjvnmsbrvdvdxmegjhmvadkforlftmbphhsduibqirocamanvuucujuculsaidydgehfkoipwkezodjqqdtyddffrxtkrqwfsojtnuuwlnsncqmgbpobdzhvxpajxvtfylhtzagllcgqzyiuhdiaxpuqxuhfzqhmhivqgkbsfgqubomtqwazldrzfcalvovzrojkzgiilkusnnggqpdsjsuosttevexrlatqoxxulxxrdwecgvanhsgrpcwsolyacsyywtbekgvjkrigimndlmtnueyabiaawipwdxqbhjmzzmwutqrbqmmpjeqelollqnvkwumvooludxrhdffcnlwhaihjpqjmhvjesyfqrbszanjgmfefpbojhkisuqvizigzripxvsrvgnpnmhmcdgwsjdrkvucqfpxlbfjzbbzcbaotkxavrrahirdvkzvkkdkzuczqizmfbjtorrbzrlfzrlvmntzbfarscmffrjkyhfbnekecdmbbipleaprfqkttyvamdtygnoccjqtiwufndbugdystjhskbrhicefvqginyrtivrmlrfzjrulfsvdunaahwlczngqydkuhwbayhjmemgcyironnomlqkrwxvqlpsrcvhfrqasirfnidxfszaixizoxqrugkqptoyeryqclgpphgtrearzcrgyyzmfxsysmtbdbciahqguwkxmyrmmmiiqjidmguzbprtaauunkzsvocswehrntlzvtvjquoyyipunsyqlzhavgdknnkyzhpunkgpphchdiurdpjsyfjblyqovujganrvsliqhjxchhpersselllpejipdpzazrzsmvepucfvtkxjokzcpwfvrksewtmhnhrhtbsdnkxwzhqkljgvactevxrutdbovtwkbkslsbtzacftencilzfkomuismorquhapjxbovyvtrtxlrfwobtrwzpvwjexemkywrjnvvwdfyuzwjbdmrarwwkvtaaebymlcentfhfyftrquqzquqfcnemojpjujqnmcuftulyvyzdzzsjcqrcwtucskqotbjhdakubdfawtbmxvtxqnowpaccqyrljlsfgszfwkucaduetzfzotkfavfdfpilrmybwzrdgafllcgpuzqmtxkbljunzqebimusrevpomqzpfhpflqxjsebmgmbvotnonrudfixepkveqceredjwttlmhoqkipfhubnkmemrrmggaqbumbdqmmndqkbzgoagbkgxuukaoxpegfjyzizkgmmycptufoqjpofvhnvplvdedqhsmjgaiglassmrlrrrrudwkiuzmkkyyfqrnbjtczvootntkvuwhtrvbmmauwgsvifbdoxrnmvvwtysrgspkrgujkjbpomlnkvgssinkxhduoyhxoqgtdgfhnwjgbbvpyotrejadpovopcwkrviwmbaoydbinhdwnfsokcijukguchntkzmaavbfgiruxsxyukizarkdlyadukpwcifdbujsipuueamocrcsoeksejirdfxfhxyqvnseljweqzkvesgpviswrcvzgcgbjgsiquljznvwaeajsdyidlbojnmnhobqrcxytmtlbabxfcmzpefnjcoxhqinmfjhcytenyjjwdlnudakklpbmuddkrgdoiboekmpiuyphtoakybyfnvhudxoqrbcacqacaayqprbjqkxboruapsdgjsolbibviqpeyahqywiygdjmhdrdtrafegejizjptzrarxbathcwqmumsoroyixdbqevehujycytgbbnufdinebldnis"
    print "Tests starting"
    m.opCount = 1000
    m.testResults = []

    ' typeCall()
    ' paramTypeCall()
    ' typePerf()
    ' typePerfWithGetInterface()
    ' intTypeCheck()
    ' md5()
    ' stringVsArrayKeyLookups()
    'literalVsSingleAALookup()
    ' stringConcatGrouping()
    arrayInOrder()
    ' forIndexVsForEach()

    printResults(m.testResults)

    startTime = CreateObject("roDateTime")
    'the print buffer isn't flushed when the app dies, so spin till it flushes
    print " "
    while CreateObject("roDateTime").AsSeconds() - startTime.AsSeconds() < 1
    end while
end sub


sub forIndexVsForEach()
    array = []
    for i = 0 to 1000
        array.push({
            id: i
        })
    end for

    runTest("for index (external)", function(opCount, array)
        for op = 0 to opCount
            for i = 0 to getCount(array)
                temp = array[i]
            end for
        end for
    end function, array)

    runTest("for index (lifted)", function(opCount, array)
        for op = 0 to opCount
            arrayCount = array.count()
            for i = 0 to arrayCount
                temp = array[i]
            end for
        end for
    end function, array)

    runTest("for index", function(opCount, array)
        for op = 0 to opCount
            for i = 0 to array.Count()
                temp = array[i]
            end for
        end for
    end function, array)

    runTest("for each", function(opCount, array)
        for op = 0 to opCount
            arrayCount = array.count()
            for each item in array
                temp = invalid
            end for
        end for
    end function, array)
end sub

function getCount(arr)
    return arr.Count()
end function

sub arrayInOrder()
    baseArray = []
    for i = 100 to 600
        baseArray.push({
            id: i
        })
    end for

    for i = 700 to 1100
        baseArray.push({
            id: i
        })
    end for

    childArrayStart = []
    childArrayMid = []
    childArrayEnd = []
    for i = 1 to 99
        childArrayStart.push({
            id: i
        })
        childArrayMid.push({
            id: 600 + i
        })
        childArrayEnd.push({
            id: 1100 + i
        })
    end for

    runTest("array append", function(opCount, baseArray)
        for i = 0 to opCount
            testArray = []
            testArray.append(baseArray)
        end for
    end function, baseArray)

    runTest("sort at beginning", function(opCount, baseArray, childArray)
        for i = 0 to opCount
            testArray = []
            testArray.append(baseArray)
            testArray.append(childArray)
            testArray.sortBy("id")
        end for
    end function, baseArray, childArrayStart)

    runTest("sort at middle", function(opCount, baseArray, childArray)
        for i = 0 to opCount
            testArray = []
            testArray.append(baseArray)
            testArray.append(childArray)
            testArray.sortBy("id")
        end for
    end function, baseArray, childArrayMid)

    runTest("sort at end", function(opCount, baseArray, childArray)
        for i = 0 to opCount
            testArray = []
            testArray.append(baseArray)
            testArray.append(childArray)
            testArray.sortBy("id")
        end for
    end function, baseArray, childArrayEnd)

    runTest("manual build at beginning", function(opCount, baseArray, childArray)
        for op = 0 to opCount
            result = []
            firstChildId = childArray[0].id
            found = false

            for each item in baseArray
                'append the child array to the result when we found the right spot
                if not found and item.id > firstChildId
                    found = true
                    for each child in childArray
                        result.push(child)
                    end for
                end if
                result.push(item)
            end for
            if found = false
                for each child in childArray
                    result.push(child)
                end for
            end if
            for i = 0 to result.count() - 2
                if result[i].id > result[i + 1].id then
                    print "bad", result[i], result[i + 1]
                    throw "bad"
                end if
            end for
        end for
    end function, baseArray, childArrayStart)


    runTest("manual build at middle", function(opCount, baseArray, childArray)
        for op = 0 to opCount
            result = []
            firstChildId = childArray[0].id
            found = false

            for each item in baseArray
                'append the child array to the result when we found the right spot
                if not found and item.id > firstChildId
                    found = true
                    for each child in childArray
                        result.push(child)
                    end for
                end if
                result.push(item)
            end for
            if found = false
                for each child in childArray
                    result.push(child)
                end for
            end if
            for i = 0 to result.count() - 2
                if result[i].id > result[i + 1].id then
                    print "bad", result[i], result[i + 1]
                    throw "bad"
                end if
            end for
        end for
    end function, baseArray, childArrayMid)

    runTest("manual build at end", function(opCount, baseArray, childArray)
        for op = 0 to opCount
            result = []
            firstChildId = childArray[0].id
            found = false

            for each item in baseArray
                'append the child array to the result when we found the right spot
                if not found and item.id > firstChildId
                    found = true
                    for each child in childArray
                        result.push(child)
                    end for
                end if
                result.push(item)
            end for
            if found = false
                for each child in childArray
                    result.push(child)
                end for
            end if
            for i = 0 to result.count() - 2
                if result[i].id > result[i + 1].id then
                    print "bad", result[i], result[i + 1]
                    throw "bad"
                end if
            end for
        end for
    end function, baseArray, childArrayEnd)
end sub

sub stringConcatGrouping()
    runTest("literal assignment", function(opCount)
        local = "string"
        for i = 0 to opCount
            local = "string"
        end for
    end function)

    runTest("literal assignment", function(opCount)
        local = "string"
        for i = 0 to opCount
            local = ("string")
        end for
    end function)
end sub

sub literalVsSingleAALookup()
    runTest("literal assignment", function(opCount)
        obj = {}
        for i = 0 to opCount
            obj.prop = "#FFFFFF"
        end for
    end function)

    runTest("small aa dotted get assignment", function(opCount, dictionary)
        obj = {}
        for i = 0 to opCount
            obj.prop = dictionary.zzProp
        end for
    end function, {
        zzProp: "#FFFFFF"
    })

    dictionary = {}
    for i = 0 to 10000
        dictionary["prop" + str(i)] = "#FFFFFF"
    end for
    dictionary.zzProp = "#FFFFFF"

    runTest("large aa dotted get assignment", function(opCount, dictionary)
        obj = {}
        for i = 0 to opCount
            obj.prop = dictionary.zzProp
        end for
    end function, dictionary)

    runTest("small aa indexed get assignment", function(opCount, dictionary)
        obj = {}
        for i = 0 to opCount
            obj.prop = dictionary["zzProp"]
        end for
    end function, {
        zzProp: "#FFFFFF"
    })

    dictionary = {}
    for i = 0 to 10000
        dictionary["prop" + str(i)] = "#FFFFFF"
    end for
    dictionary.zzProp = "#FFFFFF"

    runTest("large aa dotted get assignment", function(opCount, dictionary)
        obj = {}
        for i = 0 to opCount
            obj.prop = dictionary["zzProp"]
        end for
    end function, dictionary)
end sub

sub paramTypeCall()
    runTest("typed function 10 params", function(opCount)
        for i = 0 to opCount
            doNothingTyped10params(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
        end for
    end function)

    runTest("untyped function 10 params", function(opCount)
        for i = 0 to opCount
            doNothingUntyped10Params(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
        end for
    end function)

    runTest("typed function 5 params", function(opCount)
        for i = 0 to opCount
            doNothingTyped5params(0, 1, 2, 3, 4)
        end for
    end function)

    runTest("untyped function 5 params", function(opCount)
        for i = 0 to opCount
            doNothingUntyped5Params(0, 1, 2, 3, 4)
        end for
    end function)

    runTest("typed function 1 param", function(opCount)
        for i = 0 to opCount
            doNothingTyped1params(0)
        end for
    end function)

    runTest("untyped function 1 param", function(opCount)
        for i = 0 to opCount
            doNothingUntyped1Params(0)
        end for
    end function)

    runTest("empty loop", function(opCount)
        for i = 0 to opCount
            'do literally nothing
        end for
    end function)
end sub

sub doNothingTyped10params(p0 as integer, p1 as integer, p2 as integer, p3 as integer, p4 as integer, p5 as integer, p6 as integer, p7 as integer, p8 as integer, p9 as integer)
    'result = p0 + p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9
end sub

sub doNothingUntyped10Params(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)
    'result = p0 + p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9
end sub

sub doNothingTyped5params(p0 as integer, p1 as integer, p2 as integer, p3 as integer, p4 as integer)
    'result = p0 + p1 + p2 + p3 + p4 + 5 + 6 + 7 + 8 + 9
end sub

sub doNothingUntyped5Params(p0, p1, p2, p3, p4)
    'result = p0 + p1 + p2 + p3 + p4 + 5 + 6 + 7 + 8 + 9
end sub

sub doNothingTyped1params(p0 as integer)
    'result = p0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
end sub

sub doNothingUntyped1Params(p0)
    'result = p0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9
end sub

sub typeCall()
    runTest("type x 1", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = type(text)
        end for
    end function)

    runTest("type x 2", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = type(text)
            result = type(text)
        end for
    end function)

    runTest("type x 3", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = type(text)
            result = type(text)
            result = type(text)
        end for
    end function)

    runTest("type x 4", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = type(text)
            result = type(text)
            result = type(text)
            result = type(text)
        end for
    end function)

    runTest("type x 5", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = type(text)
            result = type(text)
            result = type(text)
            result = type(text)
            result = type(text)
        end for
    end function)

end sub

sub typePerfWithGetInterface()
    runTest("getInterface integer", function(opCount)
        value = 0
        for i = 0 to opCount
            result = getinterface(value, "ifInt") <> invalid
        end for
    end function)

    runTest("getInterface roInt", function(opCount)
        value = createObject("roInt")
        for i = 0 to opCount
            result = getinterface(value, "ifInt") <> invalid
        end for
    end function)

    runTest("type integer", function(opCount)
        value = 0
        for i = 0 to opCount
            valueType = type(value)
            result = valueType = "Integer" or valueType = "roInt"
        end for
    end function)

    runTest("type roInt", function(opCount)
        value = createObject("roInt")
        for i = 0 to opCount
            valueType = type(value)
            result = valueType = "Integer" or valueType = "roInt"
        end for
    end function)
end sub

sub intTypeCheck()
    runTest("type call each time - equality", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = type(text) = "Integer" or type(text) = "roInt"
        end for
    end function)

    runTest("lifted type call - equality", function(opCount)
        text = m.longText
        for i = 0 to opCount
            valueType = type(text)
            result = valueType = "Integer" or valueType = "roInt"
        end for
    end function)

    runTest("type call each time - instr", function(opCount)
        text = m.longText
        for i = 0 to opCount
            result = instr(1, type(text), "Integer") or type(text) = "roInt"
        end for
    end function)

    runTest("lifted type call - instr", function(opCount)
        text = m.longText
        for i = 0 to opCount
            valueType = type(text)
            result = instr(1, valueType, "Integer") or valueType = "roInt"
        end for
    end function)
end sub

' Test various ways of running `type` to see which is fastest
sub typePerf()
    runTest("duplicate type checks", function(opCount)
        value = m.longText
        for i = 0 to opCount
            result = type(value) = "Integer" or type(value) = "roInt" or type(value) = "LongInteger" or type(value) = "roInteger" or type(value) = "Float" or type(value) = "roFloat" or type(value) = "Double" or type(value) = "roDouble" or type(value) = "roIntrinsicDouble"
        end for
    end function)

    runTest("liftedType", function(opCount)
        value = m.longText
        for i = 0 to opCount
            valueType = type(value)
            result = valueType = "Integer" or valueType = "roInt" or valueType = "LongInteger" or valueType = "roInteger" or valueType = "Float" or valueType = "roFloat" or valueType = "Double" or valueType = "roDouble" or valueType = "roIntrinsicDouble"
        end for
    end function)

    runTest("liftedType instr", function(opCount)
        value = m.longText
        for i = 0 to opCount
            valueType = type(value)
            result = instr(1, valueType, "Int") <> 0 or instr(1, valueType, "Float") <> 0 or instr(1, valueType, "Double") <> 0
        end for
    end function)

    runTest("helper", function(opCount)
        value = m.longText
        for i = 0 to opCount
            result = bslib_isNumber(type(value))
        end for
    end function)

    runTest("inline m assignment", function(opCount)
        value = m.longText
        for i = 0 to opCount
            result = (function(valueType)
                m.valueType = valueType
                return true
            end function)(type(value)) and (m.valueType = "Integer" or m.valueType = "roInt" or m.valueType = "LongInteger" or m.valueType = "roInteger" or m.valueType = "Float" or m.valueType = "roFloat" or m.valueType = "Double" or m.valueType = "roDouble" or m.valueType = "roIntrinsicDouble")
        end for
    end function)
end sub

function bslib_isNumber(valueType as dynamic)
    return valueType = "Integer" or valueType = "roInt" or valueType = "LongInteger" or valueType = "roInteger" or valueType = "Float" or valueType = "roFloat" or valueType = "Double" or valueType = "roDouble" or valueType = "roIntrinsicDouble"
end function

function bslib_isBoolean(valType as dynamic)
    return valType = "Boolean" or valType = "roBoolean"
end function

sub md5()
    runTest("md5", function(opCount)
        text = "kydjunsbhrtajaftfvqujclkuvfumwhzdwnwwxgpfzitrczecybufxzfkyazvrufhkeatqpwaegxjuxnvvbmhlbejxezfcbsxufsyvdcbzmwqtmsvudlejtkupinzwnsfglefnvhekehoskwsqoojanilgwrbnmjutwkolpdkajahqmetipdygxufqkudbvffrtuzmrkzzqcdicncwlckebpxbqsykuysduvfnybtdlurqxebezixelyxafelqjburwheezfzsdqwingdfgfjwacfffnpvjpcgbortelivbwqnaviwgzpjuhiwqrlemnxryozqxigaevzmtkyqidmtxegvzndydtxnzlpkwsmkexvbdiodntfarpdpwcqxjcksuomfdpazezdmlzlbmunrwlaulffptwkeunyiegscqxxwsjibvisvjrovuwctvurewqoinmvyizlnbmguwrbtwfbcghlmmvbysaedwzolrnohvksgesocanisjrmcffwwxkfokicyogajpxgvkzcctenbgrxqwcdciovcmwropqdtxjgmfggazopudrxcgnlprlftmsmmhszauoemihxnmcuwlckxfqottrcagzocnhtfjhfayrvjlssxfiotxhwulbprefgckmeohwdjxpclxkxiqiqffpcmbbtkibsyzhgvgbdanuxcfbxqohnnifuidfnznmpirbxebelcqsntoheonlbuwryiiunzvkllrltgeagjhdbsbdwbufxwopxrvibphyfnznzvzoqdawlfzhkipiwfrnyvtpikdbnccsuvsikatzwtyjocdndjxkjxejtmaxvylnaatbmszyvhjpjldhrcydmbwfgjxlataglpjpufxdxyehvmnraselsyxdgxnlvavsifgdnjgbedkmtjgzbyvuqyxcfxtedfflsbiamnfnxlziexhvatkunxdooareuwxhbyekqwbsfmgaxhrputsmacemqvvralwuxncvqngbdfktynlkrbrzykafxmyqrjizrfhxoenbmjqmjdnijcylsznxmuqmoekicveepflqupulliygxpcbchhcshbjhfrmvcfvawqaakkwymtwmzhonrmyqzcivubrxdhywankmesrzxlaavnkrdgicxdyqxmotdqjvofywkqwgdpzaspfkkzqiqxqodtwfptclgxrnilfvzvivjyoiulyitkfjilxergwimvfpjibftrewviimystoijbplpgcwkncvtjdmnqsaiyjbwsdbjcztzdjpkesyjcumncsdjzypexjnksprxwhskoyhdcqqjihlvqtyshehvlnwmtnjyxiecbzhltqqriajyvnbhmnbwhtnmomuuornbeqrwihqznutpifzojyhjaowdlgpbxvsuoihuxncadbfaameigordaanfivnihglhkgndfidlsgqbxfctgmottlujdtoenjqamjjytqjrqtgsrafqexynwcsmxrjpydqynpeezqxnrdnwmzmzvmwczqxeccqcjbxhehavyokqxnkzgmrimhenfnnavkimbyluabcavlwfgbuxvuvnaubfpqbrdjkoneauuycnakqagwetnirhvloksilmyjimfwmzzkdqxywphfbkjeszrkkeksrselgxqbkjqxihqiyvchirqpbkiychljdyrgtwlpgcmtoezfjpcebpzdrlwcndwkmkgisgjjnpzqnsmfucoskliuiqqmvpkktvicqgyshobkzadjqogauczwafxlavhmtsnnrlanrxtwoqwjluxcjxoxatlakldtprsjjtpawmloruuvfzutrordjhdstkblwpzbagpcojkrszrsznzywyleaafxigxgnipuukepieukoztfphpnwbwubvpgahzjjagosiyjkluqcydatptvszhuibgzqbiriaslrvftllgmrjnnkkyxnnbrsntujkqstfvvfqreyqirenhhruysbohaqelaecogjblfpeohobisoxxazcppbcgwzigdjwtmkrurbpaulpgdmwjgsldkwxkvuohymucwgqytbyvnuvorzdcncqakbezqzvchuphaurucvydvkpmduqmjeiuqslzjwxgruaqtndlfcnqmgtieexdbdizsznxofwglprupanftxgecqryifuaywphzvxqvcdnqmhtrxpodlwigcvjkcltgsvfpizqzdlpmgtkyblhqxdnggphctlqcpledhhiszfnxzlurvczzaqonljacehmeieupoecztngpqekdplaxnvbgjowgiyssgqjnicfjpsjshwbmkglbxjbgwkcxjmecthrgvugnluivmuecgkxzdfbytuwcoutgbyqsefzbubtdvuxzqbhrteqyyrekngayhlmsdrgdwalblifmvtoodgtuybitqgkcbpvkpgbxyfsspvbzpsxkynobvrdthgcqewnbqyefkhdwljqktfstxtkwaviibpabynthkoikcvutckfouatjhosvmfcvnazwyjnlbvjcwceyzmnubzixtdnelfferpnttghihyratydsdjdgtwgeuvlmgscfdmbejnxjcoczabwrxteisjxdfhiqrnlvvfpwvojmkoqdwojaggnmnwddyihfcoobigfsqpqblbgffbkzkgmsbfxwciwbdzyfqibtwpsanokpokzggbzqzlqhnshvpfwrtisejkswhzcfgwhznwkwejjuwxyvttnvkklizilmythgcvnbjslbvzjhprqlouukswsoecngzarhqexlmwoqnjfelxhjzrsgpqbsidktsksrfukerarrlwdsewioganokwbacwewqdyazrupnjrtmhoorogxeylywyhmoemrbduokxogfdwpbjvyilripcbswloykysphwjbfblkczxuvrzieuhsrtishpcqoyjxcnivvtkxcwnicxgqvuddfwdpluiqtjqfgovngvevzsijivyxxzoajfxgngwxawnrrhyfdfebrbtnxrtgajlmbkgizdozeypaddyynebqrowtkrdhcdxplavwyfnkkhmkoscdrvvizsnyujvmialhwjvnpzugccxrkogalrpjoajywkkgedcvrgljrbdwjlvaqbfzpjkanpvquxpifklcxthypyffyufqjctkjvnmsbrvdvdxmegjhmvadkforlftmbphhsduibqirocamanvuucujuculsaidydgehfkoipwkezodjqqdtyddffrxtkrqwfsojtnuuwlnsncqmgbpobdzhvxpajxvtfylhtzagllcgqzyiuhdiaxpuqxuhfzqhmhivqgkbsfgqubomtqwazldrzfcalvovzrojkzgiilkusnnggqpdsjsuosttevexrlatqoxxulxxrdwecgvanhsgrpcwsolyacsyywtbekgvjkrigimndlmtnueyabiaawipwdxqbhjmzzmwutqrbqmmpjeqelollqnvkwumvooludxrhdffcnlwhaihjpqjmhvjesyfqrbszanjgmfefpbojhkisuqvizigzripxvsrvgnpnmhmcdgwsjdrkvucqfpxlbfjzbbzcbaotkxavrrahirdvkzvkkdkzuczqizmfbjtorrbzrlfzrlvmntzbfarscmffrjkyhfbnekecdmbbipleaprfqkttyvamdtygnoccjqtiwufndbugdystjhskbrhicefvqginyrtivrmlrfzjrulfsvdunaahwlczngqydkuhwbayhjmemgcyironnomlqkrwxvqlpsrcvhfrqasirfnidxfszaixizoxqrugkqptoyeryqclgpphgtrearzcrgyyzmfxsysmtbdbciahqguwkxmyrmmmiiqjidmguzbprtaauunkzsvocswehrntlzvtvjquoyyipunsyqlzhavgdknnkyzhpunkgpphchdiurdpjsyfjblyqovujganrvsliqhjxchhpersselllpejipdpzazrzsmvepucfvtkxjokzcpwfvrksewtmhnhrhtbsdnkxwzhqkljgvactevxrutdbovtwkbkslsbtzacftencilzfkomuismorquhapjxbovyvtrtxlrfwobtrwzpvwjexemkywrjnvvwdfyuzwjbdmrarwwkvtaaebymlcentfhfyftrquqzquqfcnemojpjujqnmcuftulyvyzdzzsjcqrcwtucskqotbjhdakubdfawtbmxvtxqnowpaccqyrljlsfgszfwkucaduetzfzotkfavfdfpilrmybwzrdgafllcgpuzqmtxkbljunzqebimusrevpomqzpfhpflqxjsebmgmbvotnonrudfixepkveqceredjwttlmhoqkipfhubnkmemrrmggaqbumbdqmmndqkbzgoagbkgxuukaoxpegfjyzizkgmmycptufoqjpofvhnvplvdedqhsmjgaiglassmrlrrrrudwkiuzmkkyyfqrnbjtczvootntkvuwhtrvbmmauwgsvifbdoxrnmvvwtysrgspkrgujkjbpomlnkvgssinkxhduoyhxoqgtdgfhnwjgbbvpyotrejadpovopcwkrviwmbaoydbinhdwnfsokcijukguchntkzmaavbfgiruxsxyukizarkdlyadukpwcifdbujsipuueamocrcsoeksejirdfxfhxyqvnseljweqzkvesgpviswrcvzgcgbjgsiquljznvwaeajsdyidlbojnmnhobqrcxytmtlbabxfcmzpefnjcoxhqinmfjhcytenyjjwdlnudakklpbmuddkrgdoiboekmpiuyphtoakybyfnvhudxoqrbcacqacaayqprbjqkxboruapsdgjsolbibviqpeyahqywiygdjmhdrdtrafegejizjptzrarxbathcwqmumsoroyixdbqevehujycytgbbnufdinebldnis"
        for i = 0 to opCount
            bytes = createObject("roByteArray")
            bytes.fromAsciiString(text)
            evpDigest = createObject("roEVPDigest")
            evpDigest.setup("md5")
            result = evpDigest.process(bytes)
        end for
    end function)
end sub

sub stringVsArrayKeyLookups()
    json = {
        user: {
            favorites: [
                {
                    isActive: true
                }
            ]
        }
    }
    runTest("string split", sub(opCount, json, path)
        getPath = function(content as object, path as string, default = invalid as dynamic, disableIndexing = false as boolean) as dynamic
            part = invalid

            if path <> invalid
                parts = path.split(".")
                numParts = parts.count()
                i = 0

                part = content
                while i < numParts and part <> invalid
                    if not disableIndexing and (parts[i] = "0" or (parts[i].toInt() <> 0 and parts[i].toInt().toStr() = parts[i]))
                        if type(part) <> "<uninitialized>" and part <> invalid and GetInterface(part, "ifArray") <> invalid
                            part = part[parts[i].toInt()]
                        else if type(part) <> "<uninitialized>" and part <> invalid and GetInterface(part, "ifAssociativeArray") <> invalid
                            part = part[parts[i]]
                        else if type(part) = "roSGNode"
                            part = part.getChild(parts[i].toInt())
                        else
                            part = invalid
                        end if
                    else
                        if type(part) <> "<uninitialized>" and part <> invalid and GetInterface(part, "ifAssociativeArray") <> invalid
                            part = part[parts[i]]
                        else
                            part = invalid
                        end if
                    end if
                    i++
                end while
            end if

            if part <> invalid
                return part
            else
                return default
            end if
        end function

        for i = 0 to opCount
            getPath(json, path)
        end for
    end sub, json, "user.favorites.0.isActive")

    runTest("already split", sub(opCount, json, keys)
        getPath = function(content as object, parts, default = invalid as dynamic, disableIndexing = false as boolean) as dynamic
            part = invalid

            if parts <> invalid
                numParts = parts.count()
                i = 0

                part = content
                while i < numParts and part <> invalid
                    if not disableIndexing and (parts[i] = "0" or (parts[i].toInt() <> 0 and parts[i].toInt().toStr() = parts[i]))
                        if type(part) <> "<uninitialized>" and part <> invalid and GetInterface(part, "ifArray") <> invalid
                            part = part[parts[i].toInt()]
                        else if type(part) <> "<uninitialized>" and part <> invalid and GetInterface(part, "ifAssociativeArray") <> invalid
                            part = part[parts[i]]
                        else if type(part) = "roSGNode"
                            part = part.getChild(parts[i].toInt())
                        else
                            part = invalid
                        end if
                    else
                        if type(part) <> "<uninitialized>" and part <> invalid and GetInterface(part, "ifAssociativeArray") <> invalid
                            part = part[parts[i]]
                        else
                            part = invalid
                        end if
                    end if
                    i++
                end while
            end if

            if part <> invalid
                return part
            else
                return default
            end if
        end function
        for i = 0 to opCount
            getPath(json, keys)
        end for
    end sub, json, ["user", "favorites", "0", "isActive"])
end sub


function getOpsPerSec(startDate, endDate, ops)
    startMs = getMilliseconds(startDate)
    endMs = getMilliseconds(endDate)
    seconds = (endMs - startMs) / 1000
    opsPerSec = ops / seconds
    return opsPerSec
end function

function getMilliseconds(date)
    result = 0
    result += date.GetMinutes() * 60 * 1000
    result += date.GetSeconds() * 1000
    result += date.GetMilliseconds()
    return result
end function

function numberToString(num)
    result = ""
    i = 0
    while num > 1
        loopNum = (num mod 10).ToStr().Trim()
        result = loopNum + result
        num = num / 10
        i++
        if i mod 3 = 0 and num > 1 then
            result = "," + result
        end if
    end while
    result = result + "." + ((num * 10) mod 1).ToStr().Trim() + ((num * 100) mod 1).ToStr().Trim()
    return result
end function

'
' Run a single test.
' @param name - the name of the test
' @param testFn - reference to the test to run
' @param args - an array of parameters to pass as arguments to the test function
'
sub runTest(name as string, testFunc as function, arg1 = invalid, arg2 = invalid, arg3 = invalid, arg4 = invalid)
    ' for i = 0 to 3
    print name; " (RUNNING)"

    opCount = m.opCount
    if arg4 <> invalid
        startTime = CreateObject("roDateTime")
        testFunc(opCount, arg1, arg2, arg3, arg4)
        endTime = CreateObject("roDateTime")
    else if arg3 <> invalid
        startTime = CreateObject("roDateTime")
        testFunc(opCount, arg1, arg2, arg3)
        endTime = CreateObject("roDateTime")
    else if arg2 <> invalid
        startTime = CreateObject("roDateTime")
        testFunc(opCount, arg1, arg2)
        endTime = CreateObject("roDateTime")
    else if arg1 <> invalid
        startTime = CreateObject("roDateTime")
        testFunc(opCount, arg1)
        endTime = CreateObject("roDateTime")
    else
        startTime = CreateObject("roDateTime")
        testFunc(opCount)
        endTime = CreateObject("roDateTime")
    end if
    result = {
        name: name
        opsPerSec: getOpsPerSec(startTime, endTime, opCount)
    }
    print name; " (DONE)"
    m.testResults.push(result)
    ' end for
end sub

function printResults(results)
    print ""
    print "RESULTS:"
    print padRight("", 50, "_")
    print ""
    highestOpsPerSec = results[0].opsPerSec
    lowestOpsPerSec = results[0].opsPerSec
    opsPerSecMaxLen = 0
    nameLengthMaxLen = 0
    for each result in results
        'calculate slowest
        if result.opsPerSec < lowestOpsPerSec
            lowestOpsPerSec = result.opsPerSec
        end if

        'calculate highest ops/sec
        if result.opsPerSec > highestOpsPerSec
            highestOpsPerSec = result.opsPerSec
        end if

        'calculate logest ops/sec string
        opsPerSecTextLength = numberToString(result.opsPerSec).Len()
        if opsPerSecTextLength > opsPerSecMaxLen
            opsPerSecMaxLen = opsPerSecTextLength
        end if

        'calculate longest name
        if result.name.Len() > nameLengthMaxLen
            nameLengthMaxLen = result.name.Len()
        end if

    end for
    for each result in results
        postfix = ""
        if result.opsPerSec = highestOpsPerSec then
            postfix = " (fastest)"
        end if
        if result.opsPerSec = lowestOpsPerSec then
            postfix = " (slowest)"
        end if
        printResult(result, nameLengthMaxLen + 5, opsPerSecMaxLen, postfix)
    end for
end function

'
' Print a single test result
'
sub printResult(result, namePadding = 1, opsPadding = 0, postfix = "")
    print padRight(result.name + ": ", namePadding, "-"); " "; padLeft(numberToString(result.opsPerSec), opsPadding, " "); " ops/sec"; postfix
end sub

function padRight(value as string, padLength = 2 as integer, paddingCharacter = "0" as dynamic) as string
    while value.len() < padLength
        value += paddingCharacter
    end while
    return value
end function

function padLeft(value as string, padLength = 2 as integer, paddingCharacter = "0" as dynamic) as string
    while value.len() < padLength
        value = paddingCharacter + value
    end while
    return value
end function

sub noop()
end sub